    def step(self):
        """Run one stable simulation step."""
        if self.paused:
            return
            
        # Step 1: Predict positions
        gravity = wp.vec3(0.0, self.params['gravity'], 0.0)
        wp.launch(
            pbf_predict_positions_stable,
            dim=self.num_particles,
            inputs=[
                self.positions, self.velocities, self.predicted_positions,
                gravity, self.params['dt'], self.params['max_velocity']
            ],
            device=self.device
        )
        
        # Step 2: Build spatial hash
        self.hash_grid.build(self.predicted_positions, self.params['smoothing_radius'])
        
        # Step 3: Constraint projection iterations
        for iteration in range(self.params['constraint_iterations']):
            # Compute density
            wp.launch(
                pbf_compute_density_stable,
                dim=self.num_particles,
                inputs=[
                    self.predicted_positions, self.densities, self.hash_grid.id, self.params['smoothing_radius']
                ],
                device=self.device
            )
            
            # Compute lambda
            wp.launch(
                pbf_compute_lambda_stable,
                dim=self.num_particles,
                inputs=[
                    self.predicted_positions, self.densities, self.lambdas, self.hash_grid.id,
                    self.params['smoothing_radius'], self.params['rest_density'], self.params['constraint_epsilon']
                ],
                device=self.device
            )
            
            # Compute position corrections
            wp.launch(
                pbf_compute_delta_positions_stable,
                dim=self.num_particles,
                inputs=[
                    self.predicted_positions, self.lambdas, self.delta_positions, self.hash_grid.id,
                    self.params['smoothing_radius'], self.params['rest_density']
                ],
                device=self.device
            )
            
            # Apply corrections
            wp.launch(
                pbf_apply_delta_positions,
                dim=self.num_particles,
                inputs=[self.predicted_positions, self.delta_positions],
                device=self.device
            )
        
        # Step 4: Apply boundary conditions
        domain_min = wp.vec3(*self.params['domain_min'])
        domain_max = wp.vec3(*self.params['domain_max'])
        wp.launch(
            pbf_apply_boundaries_stable,
            dim=self.num_particles,
            inputs=[self.predicted_positions, self.velocities, domain_min, domain_max, 0.3],
            device=self.device
        )
        
        # Step 5: Update velocities and positions
        wp.launch(
            pbf_update_velocities_positions_stable,
            dim=self.num_particles,
            inputs=[
                self.positions, self.velocities, self.predicted_positions,
                self.params['damping'], self.params['dt'], self.params['max_velocity']
            ],
            device=self.device
        )

# Simple OpenGL Renderer
class StableRenderer:
    def __init__(self, simulation):
        self.sim = simulation
        self.camera_distance = 3.0
        self.camera_theta = 45.0
        self.camera_phi = 20.0
        self.mouse_last_x = 0
        self.mouse_last_y = 0
        self.mouse_dragging = False
        
        self.frame_count = 0
        self.last_fps_time = time.time()
        
    def init_gl(self):
        """Initialize OpenGL settings."""
        glEnable(GL_DEPTH_TEST)
        glEnable(GL_POINT_SMOOTH)
        glEnable(GL_BLEND)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
        
        glClearColor(0.02, 0.02, 0.05, 1.0)
        glPointSize(5.0)
        
    def setup_camera(self):
        """Setup camera projection and view."""
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        gluPerspective(60.0, 1.0, 0.1, 100.0)
        
        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()
        
        # Camera position
        cam_x = self.camera_distance * math.sin(math.radians(self.camera_theta)) * math.cos(math.radians(self.camera_phi))
        cam_y = self.camera_distance * math.sin(math.radians(self.camera_phi))
        cam_z = self.camera_distance * math.cos(math.radians(self.camera_theta)) * math.cos(math.radians(self.camera_phi))
        
        gluLookAt(cam_x, cam_y, cam_z,  # eye
                  0.0, 0.0, 0.0,        # center
                  0.0, 1.0, 0.0)        # up
        
    def render_particles(self):
        """Render particles as colored points."""
        positions_gpu = self.sim.positions.numpy()
        
        glBegin(GL_POINTS)
        for i in range(self.sim.num_particles):
            pos = positions_gpu[i]
            
            # Color based on height (blue to cyan gradient)
            height_factor = max(0.0, min(1.0, (pos[1] + 0.8) / 2.8))
            
            glColor4f(0.1 + height_factor * 0.4,  # Red
                     0.3 + height_factor * 0.5,  # Green  
                     0.8 + height_factor * 0.2,  # Blue
                     0.9)                         # Alpha
            
