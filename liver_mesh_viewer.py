"""
Pyglet-based 3D mesh viewer for MEDIT format files.

This application loads and visualizes tetrahedral meshes generated by warp-cgal.
Controls:
- Mouse: Rotate view
- Mouse wheel: Zoom
- WASD: Move camera
- R: Reset camera
- W: Toggle wireframe mode
- T: Toggle showing tetrahedra vs surface triangles
- ESC: Exit
"""

import pyglet
from pyglet import gl
import math
import numpy as np
import os

def gluPerspective(fov_y, aspect, z_near, z_far):
    """Manual implementation of gluPerspective."""
    fov_rad = math.radians(fov_y)
    f = 1.0 / math.tan(fov_rad / 2.0)
    
    gl.glLoadIdentity()
    
    # Apply perspective transformation
    matrix = (
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (z_far + z_near) / (z_near - z_far), (2 * z_far * z_near) / (z_near - z_far),
        0, 0, -1, 0
    )
    
    gl.glMultMatrixf((gl.GLfloat * 16)(*matrix))

class MEDITMeshLoader:
    """Loads MEDIT format mesh files."""
    
    def __init__(self):
        self.vertices = []
        self.triangles = []
        self.tetrahedra = []
        self.vertex_labels = []
        
    def load_mesh(self, filename):
        """Load a MEDIT format mesh file."""
        print(f"[INFO] Loading mesh from {filename}")
        
        with open(filename, 'r') as f:
            lines = f.readlines()
        
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            
            if line == "Vertices":
                i += 1
                num_vertices = int(lines[i].strip())
                print(f"[INFO] Loading {num_vertices} vertices...")
                
                for j in range(num_vertices):
                    i += 1
                    parts = lines[i].strip().split()
                    x, y, z = float(parts[0]), float(parts[1]), float(parts[2])
                    label = int(parts[3]) if len(parts) > 3 else 0
                    
                    self.vertices.append([x, y, z])
                    self.vertex_labels.append(label)
            
            elif line == "Triangles":
                i += 1
                num_triangles = int(lines[i].strip())
                print(f"[INFO] Loading {num_triangles} triangles...")
                
                for j in range(num_triangles):
                    i += 1
                    parts = lines[i].strip().split()
                    # MEDIT uses 1-based indexing, convert to 0-based
                    v1, v2, v3 = int(parts[0])-1, int(parts[1])-1, int(parts[2])-1
                    label = int(parts[3]) if len(parts) > 3 else 0
                    
                    self.triangles.append([v1, v2, v3, label])
                    
            elif line == "Tetrahedra":
                i += 1
                num_tetrahedra = int(lines[i].strip())
                print(f"[INFO] Loading {num_tetrahedra} tetrahedra...")
                
                for j in range(num_tetrahedra):
                    i += 1
                    parts = lines[i].strip().split()
                    # MEDIT uses 1-based indexing, convert to 0-based
                    v1 = int(parts[0])-1
                    v2 = int(parts[1])-1 
                    v3 = int(parts[2])-1
                    v4 = int(parts[3])-1
                    label = int(parts[4]) if len(parts) > 4 else 0
                    
                    self.tetrahedra.append([v1, v2, v3, v4, label])
            
            i += 1
        
        self.vertices = np.array(self.vertices, dtype=np.float32)
        self.triangles = np.array(self.triangles, dtype=np.int32)
        self.tetrahedra = np.array(self.tetrahedra, dtype=np.int32)
        
        print(f"[OK] Loaded mesh: {len(self.vertices)} vertices, {len(self.triangles)} triangles, {len(self.tetrahedra)} tetrahedra")
        
        # Center and normalize the mesh
        self._center_mesh()
        
    def _center_mesh(self):
        """Center the mesh and normalize its size."""
        if len(self.vertices) == 0:
            return
            
        # Find bounding box
        min_coords = np.min(self.vertices, axis=0)
        max_coords = np.max(self.vertices, axis=0)
        
        # Center the mesh
        center = (min_coords + max_coords) / 2
        self.vertices -= center
        
        # Scale to fit in unit cube
        size = np.max(max_coords - min_coords)
        if size > 0:
            self.vertices /= size
            
        print(f"[INFO] Mesh centered and scaled. Size: {size:.2f}")
    
    def extract_surface_triangles(self):
        """Extract surface triangles from tetrahedra for better visualization."""
        if len(self.tetrahedra) == 0:
            return self.triangles[:, :3]  # Return existing triangles
            
        # For each face of each tetrahedron, count how many tets share it
        face_count = {}
        
        for tet in self.tetrahedra:
            # Four faces of a tetrahedron
            faces = [
                tuple(sorted([tet[0], tet[1], tet[2]])),
                tuple(sorted([tet[0], tet[1], tet[3]])),
                tuple(sorted([tet[0], tet[2], tet[3]])),
                tuple(sorted([tet[1], tet[2], tet[3]]))
            ]
            
            for face in faces:
                face_count[face] = face_count.get(face, 0) + 1
        
        # Surface faces appear only once
        surface_triangles = []
        for face, count in face_count.items():
            if count == 1:
                surface_triangles.append(list(face))
        
        print(f"[INFO] Extracted {len(surface_triangles)} surface triangles from tetrahedra")
        return np.array(surface_triangles, dtype=np.int32)


class Camera:
    """Simple 3D camera with mouse and keyboard controls."""
    
    def __init__(self):
        self.distance = 3.0
        self.rotation_x = 20.0
        self.rotation_y = 45.0
        self.position = [0.0, 0.0, 0.0]
        
    def setup_projection(self, width, height):
        """Setup projection matrix."""
        gl.glMatrixMode(gl.GL_PROJECTION)
        gl.glLoadIdentity()
        gluPerspective(45.0, width/height, 0.1, 100.0)
        
    def apply_view(self):
        """Apply camera transformations."""
        gl.glMatrixMode(gl.GL_MODELVIEW)
        gl.glLoadIdentity()
        
        gl.glTranslatef(0, 0, -self.distance)
        gl.glRotatef(self.rotation_x, 1, 0, 0)
        gl.glRotatef(self.rotation_y, 0, 1, 0)
        gl.glTranslatef(-self.position[0], -self.position[1], -self.position[2])
    
    def rotate(self, dx, dy):
        """Rotate camera based on mouse movement."""
        self.rotation_y += dx * 0.5
        self.rotation_x += dy * 0.5
        self.rotation_x = max(-89, min(89, self.rotation_x))
    
    def zoom(self, delta):
        """Zoom camera in/out."""
        self.distance *= (1.1 if delta > 0 else 0.9)
        self.distance = max(0.5, min(20.0, self.distance))
    
    def move(self, dx, dy, dz):
        """Move camera position."""
        self.position[0] += dx * 0.1
        self.position[1] += dy * 0.1
        self.position[2] += dz * 0.1
        
    def reset(self):
        """Reset camera to default position."""
        self.distance = 3.0
        self.rotation_x = 20.0
        self.rotation_y = 45.0
        self.position = [0.0, 0.0, 0.0]


class MeshViewer(pyglet.window.Window):
    """Main mesh viewer application."""
    
    def __init__(self, mesh_file):
        super().__init__(1200, 800, "Liver Mesh Viewer", resizable=True)
        
        # Load mesh
        self.loader = MEDITMeshLoader()
        self.loader.load_mesh(mesh_file)
        
        # Setup camera
        self.camera = Camera()
        
        # View options
        self.wireframe_mode = False
        self.show_tetrahedra = False
        self.surface_triangles = self.loader.extract_surface_triangles()
        
        # Mouse tracking
        self.mouse_pressed = False
        self.last_mouse_x = 0
        self.last_mouse_y = 0
        
        # Keys pressed
        self.keys_pressed = set()
        
        # Setup OpenGL
        self.setup_gl()
        
        # Display info
        print("\n=== Liver Mesh Viewer ===")
        print("Controls:")
        print("  Mouse: Rotate view")
        print("  Mouse wheel: Zoom")
        print("  WASD: Move camera")
        print("  R: Reset camera")
        print("  W: Toggle wireframe mode")
        print("  T: Toggle tetrahedra/surface view")
        print("  ESC: Exit")
        print()
        
    def setup_gl(self):
        """Setup OpenGL state."""
        gl.glEnable(gl.GL_DEPTH_TEST)
        gl.glClearColor(0.1, 0.1, 0.15, 1.0)
        
    def on_draw(self):
        """Render the scene."""
        gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
        
        # Setup camera
        self.camera.apply_view()
        
        # Set polygon mode
        if self.wireframe_mode:
            gl.glPolygonMode(gl.GL_FRONT_AND_BACK, gl.GL_LINE)
            gl.glColor3f(1.0, 1.0, 1.0)
        else:
            gl.glPolygonMode(gl.GL_FRONT_AND_BACK, gl.GL_FILL)
            gl.glColor3f(0.8, 0.6, 0.4)
        
        # Render mesh
        if self.show_tetrahedra and len(self.loader.tetrahedra) > 0:
            self.draw_tetrahedra()
        else:
            self.draw_surface()
            
    def draw_surface(self):
        """Draw surface triangles."""
        if len(self.surface_triangles) == 0:
            return
            
        gl.glBegin(gl.GL_TRIANGLES)
        
        for tri in self.surface_triangles:
            if tri[0] >= len(self.loader.vertices) or tri[1] >= len(self.loader.vertices) or tri[2] >= len(self.loader.vertices):
                continue
                
            v1 = self.loader.vertices[tri[0]]
            v2 = self.loader.vertices[tri[1]] 
            v3 = self.loader.vertices[tri[2]]
            
            # Simple coloring based on position (no normals for simplicity)
            color_intensity = (v1[2] + 1.0) * 0.5  # Use Z coordinate for coloring
            gl.glColor3f(0.8 * color_intensity, 0.6 * color_intensity, 0.4 * color_intensity)
            
            gl.glVertex3f(v1[0], v1[1], v1[2])
            gl.glVertex3f(v2[0], v2[1], v2[2])
            gl.glVertex3f(v3[0], v3[1], v3[2])
            
        gl.glEnd()
        
    def draw_tetrahedra(self):
        """Draw tetrahedra (wireframe only for performance)."""
        if len(self.loader.tetrahedra) == 0:
            return
            
        gl.glBegin(gl.GL_LINES)
        
        # Only draw a subset for performance
        step = max(1, len(self.loader.tetrahedra) // 1000)
        
        for i in range(0, len(self.loader.tetrahedra), step):
            tet = self.loader.tetrahedra[i]
            
            if (tet[0] >= len(self.loader.vertices) or tet[1] >= len(self.loader.vertices) or 
                tet[2] >= len(self.loader.vertices) or tet[3] >= len(self.loader.vertices)):
                continue
            
            v1 = self.loader.vertices[tet[0]]
            v2 = self.loader.vertices[tet[1]]
            v3 = self.loader.vertices[tet[2]]
            v4 = self.loader.vertices[tet[3]]
            
            # Draw 6 edges of tetrahedron
            edges = [(v1,v2), (v1,v3), (v1,v4), (v2,v3), (v2,v4), (v3,v4)]
            
            for edge in edges:
                gl.glVertex3f(edge[0][0], edge[0][1], edge[0][2])
                gl.glVertex3f(edge[1][0], edge[1][1], edge[1][2])
        
        gl.glEnd()
    
    def on_resize(self, width, height):
        """Handle window resize."""
        gl.glViewport(0, 0, width, height)
        self.camera.setup_projection(width, height)
        
    def on_mouse_press(self, x, y, button, modifiers):
        """Handle mouse press."""
        if button == pyglet.window.mouse.LEFT:
            self.mouse_pressed = True
            self.last_mouse_x = x
            self.last_mouse_y = y
    
    def on_mouse_release(self, x, y, button, modifiers):
        """Handle mouse release."""
        if button == pyglet.window.mouse.LEFT:
            self.mouse_pressed = False
            
    def on_mouse_drag(self, x, y, dx, dy, buttons, modifiers):
        """Handle mouse drag."""
        if buttons & pyglet.window.mouse.LEFT:
            self.camera.rotate(dx, -dy)
            
    def on_mouse_scroll(self, x, y, scroll_x, scroll_y):
        """Handle mouse scroll."""
        self.camera.zoom(scroll_y)
    
    def on_key_press(self, symbol, modifiers):
        """Handle key press."""
        self.keys_pressed.add(symbol)
        
        if symbol == pyglet.window.key.ESCAPE:
            self.close()
        elif symbol == pyglet.window.key.R:
            self.camera.reset()
            print("[INFO] Camera reset")
        elif symbol == pyglet.window.key.W:
            self.wireframe_mode = not self.wireframe_mode
            print(f"[INFO] Wireframe mode: {'ON' if self.wireframe_mode else 'OFF'}")
        elif symbol == pyglet.window.key.T:
            self.show_tetrahedra = not self.show_tetrahedra
            mode = "tetrahedra" if self.show_tetrahedra else "surface"
            print(f"[INFO] Display mode: {mode}")
    
    def on_key_release(self, symbol, modifiers):
        """Handle key release."""
        self.keys_pressed.discard(symbol)
    
    def update(self, dt):
        """Update camera based on pressed keys."""
        if pyglet.window.key.W in self.keys_pressed:
            self.camera.move(0, 0, 1)
        if pyglet.window.key.S in self.keys_pressed:
            self.camera.move(0, 0, -1)
        if pyglet.window.key.A in self.keys_pressed:
            self.camera.move(1, 0, 0)
        if pyglet.window.key.D in self.keys_pressed:
            self.camera.move(-1, 0, 0)


def main():
    """Main entry point."""
    import sys
    
    # Default to the generated mesh file
    mesh_file = "meshes/cgal_mesh/liver_mesh_output.mesh"
    
    if len(sys.argv) > 1:
        mesh_file = sys.argv[1]
    
    if not os.path.exists(mesh_file):
        print(f"[ERROR] Mesh file not found: {mesh_file}")
        print("Usage: python liver_mesh_viewer.py [mesh_file.mesh]")
        print("Make sure to run test_liver_mesh_simple.py first to generate the mesh.")
        return
    
    try:
        # Create and run viewer
        viewer = MeshViewer(mesh_file)
        
        # Schedule update function
        pyglet.clock.schedule_interval(viewer.update, 1/60.0)
        
        print(f"[INFO] Starting viewer for {mesh_file}")
        pyglet.app.run()
        
    except Exception as e:
        print(f"[ERROR] Failed to run viewer: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()